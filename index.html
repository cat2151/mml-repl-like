<script src="https://minipop.github.io/sionicjs/demo/pico.min.js"></script>
<script src="https://minipop.github.io/sionicjs/dist/sionic.js"></script>
<textarea id="textarea2" rows="5" cols="10">@5 l8 o7 c
d
e</textarea>
<br>
<textarea id="textarea4" rows="1" cols="10">@5 l2 </textarea>
<br>
<textarea id="textarea3" rows="5" cols="10">c;e;g;
c;f;a;</textarea>
<input type="button" value="play" onclick="playAll()" />
<br>
<textarea id="textarea5" rows="6" cols="10" readonly></textarea>
<script>
  let textarea2 = document.getElementById("textarea2");
  let textarea3 = document.getElementById("textarea3");
  let textarea4 = document.getElementById("textarea4");
  let textarea5 = document.getElementById("textarea5");

  textarea2.addEventListener("input", playInputtedMelody);
  textarea3.addEventListener("input", inputTextareaChord);
  textarea4.addEventListener("input", inputTextareaChord);

  textarea2.addEventListener('keypress', function(e) {
    // SHIFT+ENTER
    if (e.keyCode === 13 && e.shiftKey) {
      // 改行しない
      e.preventDefault();
      // 選択した範囲のMMLを鳴らす
      playSelectedMml(textarea2);
    }
  });
  
  textarea2.addEventListener('keydown', function(e) {
    // CTRL+S
    if (e.keyCode === 83 && e.ctrlKey) {
      // ページ保存ダイアログを開かない
      e.preventDefault();
      // 選択した範囲のMMLを鳴らす
      playSelectedMml(textarea2);
    }
  });

  textarea2.addEventListener('keyup', function(e) {
    // cursor
    if (37 <= e.keyCode && e.keyCode <= 40) {
      // 現在位置のMMLを鳴らす
      playNowToneMml(textarea2);
    }
  });

  let oldMml2 = "";
  let oldMml3 = "";

  // textareaで選択した範囲または現在行のMMLを鳴らす
  function playSelectedMml(textarea) {
    let playMml = "";
    if (isSelect(textarea)) {
      // 選択範囲からmmlを得る
      playMml = createSelectedMml(textarea.value, textarea.selectionStart, textarea.selectionEnd);
    } else {
      // 現在行からmmlを得る
      const currentLineNumber = calcCurrentLineNumber(textarea.value, textarea.selectionStart)
      playMml = createCurrentLineMml(textarea.value, currentLineNumber);
    }
    Pico.pause();
    Pico.play(Sionic(playMml));
  }

  // 選択範囲のMMLを得る。選択範囲以外はnote削除する
  function createSelectedMml(mml, iStart, iEnd) {
    const mmlBefore = mml.slice(0, iStart);
    const mmlAfter = mml.slice(iEnd);
    const mmlCurrent = mml.slice(iStart, iEnd);
    // if (!containsNotes(mmlCurrent)) return mml; // 選択範囲にnotesがない場合用（無音でなく、全体を鳴らす）
    if (!containsNotes(mmlCurrent)) return ""; // 選択範囲にnotesがない場合用（無音）
    const newMml = removeNotes(mmlBefore) +
      mmlCurrent +
      removeNotes(mmlAfter);
    return newMml;
  }

  // 現在行のMMLを得る。現在行以外はnote削除する
  function createCurrentLineMml(mml, currentLineNumber) {
    const lines = splitByLine(mml);
    // if (currentLineNumber < 0) return mml;
    if (currentLineNumber < 0) return "";
    // if (currentLineNumber >= lines.length) return mml; // 末尾に改行追加した場合用 
    if (currentLineNumber >= lines.length) return "";
    const mmlBefore = lines.slice(0, currentLineNumber).join('');
    const mmlAfter = lines.slice(currentLineNumber + 1).join('');
    const mmlCurrent = lines[currentLineNumber];
    // if (!containsNotes(mmlCurrent)) return mml; // 現在行にnotesがない場合用（無音でなく、全体を鳴らす）
    if (!containsNotes(mmlCurrent)) return ""; // 現在行にnotesがない場合用（無音）
    const newMml = removeNotes(mmlBefore) +
      mmlCurrent +
      removeNotes(mmlAfter);
    return newMml;
  }

  // 範囲選択中か得る
  function isSelect(textarea) {
    return textarea.selectionStart != textarea.selectionEnd;
  }
  
  // 現在行の行番号を得る
  function calcCurrentLineNumber(str, selectionStart) {
    let beforeStr = str.substr(0, selectionStart);
    let beforeLines = beforeStr.split(/\n/);
    return beforeLines.length - 1; 
  }

  function playAll() {
    const mml2 = textarea2.value;
    const mmlChord = textarea3.value;
    const mmlHead = textarea4.value;
    const parallelizedMml = parallelizeMml(mmlChord);
    const headAddedMml = createHeadAddedMml(parallelizedMml, mmlHead);
    const mml = mml2.replace(/\n/g, '') + ";\n" + headAddedMml;
    Pico.pause();
    Pico.play(Sionic(mml));
    textarea5.textContent = mml;
    oldMml2 = mml2;
    oldMml3 = mmlChord;
  }

  // 現在位置のMMLを鳴らす
  function playNowToneMml(textarea) {
    let newMml;
    if (isNote(textarea.value, textarea.selectionStart)) {
      newMml = createNowToneMml(textarea.value, textarea.selectionStart);      
    } else {
      newMml = "";
    }
    Pico.pause();
    Pico.play(Sionic(newMml));
  }

  // 入力した音のみを鳴らす
  function playInputtedMelody() {
    const mml2 = textarea2.value;
    let newMml;
    const isInserted = (oldMml2.length < mml2.length);
    if (isInserted) {
      newMml = createNowToneMml(textarea2.value, textarea2.selectionStart - 1);
    } else {
      if (isNote(textarea2.value, textarea2.selectionStart)) {
        newMml = createNowToneMml(textarea2.value, textarea2.selectionStart);
      } else {
        newMml = "";
      }
    }
    Pico.pause();
    Pico.play(Sionic(newMml));
    oldMml2 = mml2;
  }

  function isNote(mml, iStart) {
    return mml.slice(iStart, iStart + 1).match(/[a-g]/);
  }

  // 現在位置のMMLを得る。そこ以外はnote削除する
  function createNowToneMml(mml, iStart) {
    // + / -
    for (; 0 <= iStart; iStart--) {
      const isPlusMinus = mml[iStart].match(/[\+\-]/);
      if (!isPlusMinus) break;
    }    
    let iEnd = iStart + 1;
    // + / -
    for (iEnd = iStart + 1; iEnd < mml.length; iEnd++) {
      const isPlusMinus = mml[iEnd].match(/[\+\-]/);
      if (!isPlusMinus) break;
    }
    return createSelectedMml(mml, iStart, iEnd);
  }

  function inputTextareaChord() {
    const mmlChord = textarea3.value;
    const mmlHead = textarea4.value;
    const repledMml = createMmlReplLike(mmlChord, oldMml3);
    const parallelizedMml = parallelizeMml(repledMml);
    const headAddedMml = createHeadAddedMml(parallelizedMml, mmlHead);
    Pico.pause();
    Pico.play(Sionic(headAddedMml));
    textarea5.textContent = headAddedMml;
    oldMml3 = mmlChord;
  }

  // 差分を元に現在行だけ鳴らす
  function createMmlReplLike(mml, oldMml) {
    const oldLines = splitByLine(oldMml);
    const lines = splitByLine(mml);
    const currentLineNumber = searchFirstDifferenceLineNumber(lines, oldLines);
    if (currentLineNumber < 0) return mml;
    if (currentLineNumber >= lines.length) return mml; // 末尾に改行追加した場合用 
    const mmlBefore = lines.slice(0, currentLineNumber).join('');
    const mmlAfter = lines.slice(currentLineNumber + 1).join('');
    const mmlCurrent = lines[currentLineNumber];
    // if (mmlCurrent == undefined) mmlCurrent = ''; // 末尾に改行追加した場合用
    if (!containsNotes(mmlCurrent)) return mml; // 現在行をnotesなしeditした場合用（無音でなく、全体を鳴らす）
    const newMml = removeNotes(mmlBefore) +
      mmlCurrent +
      removeNotes(mmlAfter);
    return newMml;
  }

  function splitByLine(mml) {
    const arr = mml.split("\n");
    return arr;
  }

  function searchFirstDifferenceLineNumber(lines, oldLines) {
    const lenLines = lines.length;
    const lenOldLines = oldLines.length;
    const lenMin = Math.min(lenLines, lenOldLines)
    for (let i = 0; i < lenMin; i++) {
      if (lines[i] != oldLines[i]) return i;
    }
    if (lenLines > lenOldLines) {
      // 末尾にn行追加した場合
      return lenLines;
    }
    if (lenLines < lenOldLines) {
      // 末尾n行を削除した場合
      return lenLines;
    }
    // playボタンを押した場合
    return -1;
  }

  function removeNotes(mml) {
    const re = /[a-g][\+\-]*/g
    return mml.replace(re, '');
  }

  function containsNotes(mml) {
    const re = /[a-g][\+\-]*/g
    return mml.match(re);
  }
  // example : "c;e;g; \n c;f;a;" -> "cc ; ef ; ga"
  function parallelizeMml(mml) {
    const lines = splitByLine(mml);
    const lenLines = lines.length;
    const maxTrackNumber = calcMaxTrackNumber(lines);
    let tracks = new Array(maxTrackNumber);
    for (let phase = 0; phase < lenLines; phase++) {
      updateTracks(lines[phase], tracks);
    }
    const results = tracks.join(';\n')
    // console.log(results);
    return results;
  }
  // console.log(parallelizeMml("c;e;g; \n c;f;g;")); // test
  //    
  function updateTracks(line, tracks) {
    const nowTracks = line.split(';');
    const lenNowTracks = nowTracks.length;
    for (let i = 0; i < lenNowTracks; i++) {
      if (tracks[i] == undefined) tracks[i] = '';
      tracks[i] += calcNowTrackNote(nowTracks[i]);
    }
    return tracks;
  }
  // console.log(updateTracks("c;e;g",[,,])); // test
  // console.log(updateTracks("c;f;a",["c","e","g"])); // test
  //
  function calcNowTrackNote(mml) {
    if (!mml) return "r";
    return mml;
  }

  function calcMaxTrackNumber(arr) {
    const lenArr = arr.length;
    let maxSeparates = 0;
    for (let i = 0; i < lenArr; i++) {
      const line = arr[i];
      const numOfSeparates = (line.match(/\;/g) || []).length;
      if (numOfSeparates > maxSeparates) maxSeparates = numOfSeparates;
    }
    return maxSeparates + 1;
  }
  //console.log(calcMaxTrackNumber(["a;b;c","a"])); // test
  //
  function createHeadAddedMml(mml, headMml) {
    mml = mml.replace(/\n/g, '');
    let arr = mml.split(";");
    const arrLength = arr.length;
    for (let i = 0; i < arrLength; i++) {
      arr[i] = headMml + arr[i];
    }
    const results = arr.join(';\n');
    // console.log(results);
    return results;
  }
</script>
